### 聚合

#### 类的关系
在理解聚合的概念之前，需要先理清面向对象设计中类之间的关系。

对象建模需要表达的类关系包括：
- 泛化（generalization）
- 关联（association）
- 依赖（dependency）

1、泛化关系

泛化关系体现了通用父类和特定子类之间的关系。在编程语言中往往表示为子类继承自父类或子类派生自父类。
泛化关系在UML类图中以空心三角形加实线的形式表现。

泛化关系会导致子类与父类之间的耦合，父类发生的任何变更都会传递给子类，形成所谓的”脆弱的父类“。
在面向对象设计要素中，我们往往使用继承这一术语来表示泛化关系。

2、关联关系
关联关系代表了类之间的一种结构关系，用以指定一个类的对象与另一个类的对象之间存在连接关系。
关联关系包括一对一、一对多、多对多关系，在UML类图中分别用连线和数字标记关联关系和关系的数量。
如果两个类之间的关联关系存在方向，则需要使用箭头表示关联的导航方向。如果没有箭头，就表示双向关联。

组合关系：
存在一种特殊的关联关系：关联双方分别体现整体与部分的特征，代表整体的对象包含了代表部分的对象。
依据关系的强弱，组合关系又分为合成（composition）关系与聚合（aggregation）关系。

- 合成关系
合成关系不仅代表了整体与部分的关系，还体现了强烈的”所有权“特征。
这种所有权使得二者的生命周期存在一种啮合关系，即组成合成关系的两个对象属于同一个生命周期。
当代表整体概念的主体对象被销毁时，代表部分概念的从对象也将随之而被销毁。
- 聚合关系
聚合关系同样代表了整体和部分的包含关系，却没有所有权特征，不会约束它们的生命周期，故而关联强度要弱于合成关系。

显然，满足组合关系的两个类不应该存在多对多关系，因为两个类不可能互为整体和部分。

3、依赖关系
依赖关系代表一个类使用了另一个类的信息或服务。
依赖双方耦合较弱。
依赖关系产生于：
- 类的方法接收了另一个类的参数；
- 类的方法返回了另一个类的对象；
- 类的方法内部创建了另一个类的示例；
- 类的方法内部使用了另一个类的成员。

#### 模型的设计约束
领域对象模型表达了领域概念映射的类以及类之间的关系，类的关系导致了对象之间的耦合。
如果不对类的关系加以控制，耦合就会蔓延。一旦需要考虑数据持久化、一致性、对象之间的通信机制以及加载数据的性能等设计约束，
网状的耦合关系就会成为致命毒药，直接影响领域驱动设计模型的质量。

1、控制类的关系

- 去除不必要的关系：如果确定类之间的关系没有必要存在，就要斩断它；
- 降低耦合的强度：引入泛化提取通用特征，形成更弱的依赖或关联关系；正确识别合成还是聚合关系，也能降低耦合强度；
```java

```
- 避免双向耦合：

2、引入边界

在一个复杂的软件系统中，即使通过正确地甄别和控制关系来改进模型，但由于规模的原因，由对象建立的模型最终还是会形成下图所示的一张彼此互联互通的对象网。
对关系的控制可以让对象模型中类之间的关系变得更简单。同时还需要**引入边界来降低和限制领域类之间的关系**。

如何控制边界：
- 依据”高内聚低耦合“的原则，将高内聚的类放在一个边界内，形成各自的边界（这种边界不是限界上下文的边界而是类的边界）
- 每个边界定义一个主对象，边界外的对象只能访问边界内的主对象
根据以上方法划分的边界称为**聚合**，边界内的主对象称为**聚合根**

#### 聚合的定义与特征
定义：

将实体和值对象划分为聚合并围绕着聚合定义边界。选择一个实体作为每个聚合的根，并允许外部对象仅能持有聚合根的引用。
作为一个整体来定义聚合的属性和不变量，并将执行职责赋予聚合根或指定的框架机制。

特征：
- 聚合是包含了实体和值对象的一个边界（聚合内部只能包含实体和值对象）；
- 聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根。这个根称为聚合根，这个实体称为根实体；
- 外部对象只允许持有聚合根的引用，以起到边界的控制作用；
- 聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性，体现业务上的不变量约束；
- 由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。

面向对象的聚合（OO聚合）与领域驱动设计聚合（DDD聚合）的区别：
OO聚合：Account（账户）与Transaction（交易）之间存在整体与部分的关系，Account包含多个Transaction记录
DDD聚合：一个Account对象可以聚合0~n个Transaction对象，但他们却分别属于两个不同的DDD聚合。

#### 聚合的设计原则
1、完整性

聚合作为一个受到边界控制的领域共同体，对外由聚合根体现为一个统一的概念，对内则管理和维护着高内聚的对象关系。对内对外具有一致的生命周期。
例如：订单聚合由Order聚合根实体体现订单的领域概念，其中的OrderItem（订单商品）和Address（配送地址）不能脱离订单单独存在。
这些对象在创建订单时需要一并创建且拥有共同的生命周期。如果聚合中对象的生命周期不一致就违背了一致性。

完整性除了可以通过聚合来保证，也可以通过聚合之间的关系来保证，二者无非是约束机制不同。

2、独立性

考虑独立性时，可以针对聚合内的非聚合根实体（除聚合根实体外的其他实体）询问：
- 目标聚合是否已经足够完整
- 带合并实体是否会被调用者单独使用

例如：在线试题领域中Question（问题）与Answer（答案）之间，Answer无法独立与Question单独存在，因此二者在同一个聚合中。
在线问答平台领域中，对一个Question用户可以有不同的Answer并且可以针对Answer进行点赞、评论、分享、收藏等操作。
这些操作赋予了Answer独立的行为，此时Question和Answer就可以独立成两个聚合，通过引用来维持Question聚合的完整性。

不同于实体，值对象不存在这种独立性，因为值对象不能脱离实体单独称为一个聚合。

3、不变量

在数据发生变化时必须保持的一致性规则，涉及聚合成员之间的内部关系。
不变量代表了领域逻辑中的业务规则或验证条件，有时也可将不变量理解为“不变条件”或“固定规则”。

例如：在航班计划限界上下文中，编写“修改航班计划起飞时间与计划到达时间”这一业务服务规则时，有如下标准：
若该航班有共享航班，在修改航班计划起飞时间与到达时间时，关联的所有共享航班的计划起飞时间与计划到达时间也要随之修改，以保持与主航班的一致性。

这一验收标准可以视为航班与共享航班之间的不变量。针对这一业务场景，需要将Flight与SharedFlight两个实体放入同一个聚合且以Flight为聚合根。

例如：报表系统中“报表类别名称不可少于8个字符且不能重复”

这一规则是验证条件，对报表聚合内部报表类别值对象的Name属性进行单独验证，没有聚合对象之间的关系进行约束，非不变量。

4、一致性


